<!doctype html>
<html lang="fr">

<head>
	<meta charset="utf-8">

	<title>Git Basics</title>

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="stylesheet" href="../../../dist/reveal.css">
	<link rel="stylesheet" href="../../../dist/theme/dracula.css" id="theme">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="../../../plugin/highlight/monokai.css">

	<style type="text/css">
		.reveal ul {
			display: block;
		}

		.reveal p {
			text-align: left;
		}
	</style>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<section data-markdown>
					<textarea data-template>
						# Git

						Git est un logiciel de gestion de versions décentralisé. 
						
						C'est un logiciel libre (GPLv2), créé en 2005 par Linus Torvalds, pour le noyau Linux.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Gestion de versions

						Gérer l'ensemble des versions d'un ou plusieurs fichiers et les modifications concurrents sur ceux-ci.

						* Concurent Version System (CVS)
						* Visual SourceSafe (VSS)
						* Subversion (SVN)
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Décentralisé

						Multiple dépots de code (Github, Gitlab hum hum). Notion de dépot (repository) local.

						* Perforce
						* BitKeeper
						* Mercurial
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# Termes et notions communes

						On peut retrouver plusieurs analogies dans les nom de commandes Git.

						### Arbre 
						
						* clone
						* root
						* trunk
						* branch
						* cherry-picking
						
						### Rivière 
						
						* fork
						* merge
						* downstream
						* upstream
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### `Repository`

						Dépot contenant le code.

						### `Clone`

						Créer une copie locale d'un repository.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Change | `Diff`

						Changement apporté à un fichier.

						### Commit (nom) | `Changeset`

						Liste de change appliqué de manière atomique.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Version | Revision

						Etat complet du repository pour un commit donné.

						### `Blame` | Annotate

						Commit et auteur de la dernière modification d'une ligne donné.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### `Branch` | Fork (!)

						Embranchement dans l'arbre des commits.

						### Trunk | Master | Mainline | Main

						Branche principale.

						### `Tag` | Label

						Pointeur sur un commit particulier.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### `Merge`

						Réconcilier des changements entre 2 versions.

						### `Conflict`

						Changement réalisé sur la même partie de fichier par deux personnes différentes.

						### Resolve

						Action du développeur pour résoudre un conflit.
					</textarea>
				</section>

				<section>
					<div class="mermaid">
						<pre>
							%%{init: { 'theme': 'base' , 'themeVariables': {
								'commitLabelColor': '#ffffff',
								'lineColor': '#ffffff',
								'commitLabelBackground': 'transparent',
								'commitLabelFontSize': '20px',
								'tagLabelFontSize': '18px'
						 	} } }%%
							gitGraph:
								commit id: "1"
								commit id: "2"
								branch branche
								commit id: "3"
								commit id: "4"
								checkout main
								commit id: "5"
								checkout branche
								commit id: "6"
								checkout main
								merge branche id: "7" tag: "tag_1"
								branch branche_abandonnee
								checkout main
								commit id: "8"
								branch branche_2
								checkout branche_abandonnee
								commit id: "9"
								checkout branche_2
								commit id: "10" tag: "tag_2"
								branch branche_3
								checkout branche_2
								commit id: "11"
								checkout main
								merge branche_2 id: "12" tag: "tag_3"
								commit id: "13"
								checkout branche_3
								commit id: "14"
								commit id: "15"
								checkout main
								commit id: "16"
						</pre>
					</div>
				</section>


				<section data-markdown>
					<textarea data-template>
						### `Working Copy`

						Dossier de travail local.

						### Staging | `Index`

						Etape intermédiaire avant un commit.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### `Commit` (action)

						Envoyer un commit vers un repository.

						### `Checkout` | Update (!)

						Mettre à jour sa Working Copy.

						### `Push` | `Fetch` | `Pull` (!)

						Synchroniser deux repository.

					</textarea>
				</section>

				<section>
					<img src="https://k21academy.com/wp-content/uploads/2020/07/dvcs.png">
				</section>

				<section data-markdown>
					<textarea data-template>
						### Pull / Merge Request

						Fonctionnalité spécifique de Github / Gitlab pour mettre à jour une branche depuis une autre branche ou un autre repository

						### Fork (Github)

						Clone d'un repository dans un autre namespace

						### Pipelines (Gitlab) | Actions (Github)

						Permet de lancer des "scripts" selon certaines conditions
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# Concepts avancés

						Les concepts suivants (et d'autres) seront traités dans d'autres modules:

						* Stash
						* Cherry picking
						* Bisect
						* Revert
						* Reset
						* Rebase
						* Reflog
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# Utiliser Git

						* CLI
						* IntelliJ
						* VS Code
						* [GitHub Desktop](https://github.com/apps/desktop)
						* [SourceTree](https://www.sourcetreeapp.com/)

						https://git-scm.com/download/gui/windows
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						# Utiliser Git

						### https://git.vs.ch/formations/git/base/-/blob/main/tutorial/cli.md

						### https://git.vs.ch/formations/git/base/-/blob/main/tutorial/intellij.md
						
						### https://git.vs.ch/formations/git/base/-/blob/main/tutorial/VSCode.md
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						# Première utilisation

						### https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup

						```
						git config --global user.name "Gilles Crettenand"
						git config --global user.email gilcrt@admin.vs.ch
						```

						```
						git config --global core.editor vim
						```

						### Vérifier la config

						```
						git config -l
						```
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# Authenfication
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Deux protocoles

						* ssh://git@git.vs.ch:2222/repo.git
						* https://git.vs.ch/repo.git
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## SSH

						Méthode recommandée.

						* `ssh-keygen -t ed25519 -C "<username>@admin.vs.ch"`
						* Ouvrir `C:\Users\<username>\.ssh\id_ed25519.pub`
						* https://git.vs.ch/-/user_settings/ssh_keys

						Une fois la clef créée, elle sera normalement utilisé automatiquement par le CLI et les IDE.

						Projet d'automatisation via le compte utilisateur, aussi pour les serveurs Linux.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## SSH-agent

						Un ssh-agent permet de "transférer" les clefs SSH local vers les serveurs distants pour une auehtntification transparente.

						* [Putty (via Pageant)](https://www.digitalocean.com/community/tutorials/how-to-use-pageant-to-streamline-ssh-key-authentication-with-putty)
						* [MobaXTerm](https://docs.gcc.rug.nl/hyperchicken/ssh-agent-forwarding-mobaxterm/)
						* [Windows natif](https://learn.microsoft.com/fr-ch/windows-server/administration/openssh/openssh_keymanagement)
						* [Remote Desktop Manager](https://docs.devolutions.net/rdm/commands/tools/key-agent-manager/)
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## HTTPS

						* `https://git.vs.ch/repo.git`
						* `https://<username>@git.vs.ch/repo.git`
						* `https://<username>:<password>@git.vs.ch/repo.git` (*)
						* `https://<username>:<token>@git.vs.ch/repo.git` (*)

						[Stockage des credentials](https://git-scm.com/docs/gitcredentials)

						<sup>\* Attention à l'historique des commandes !</sup>
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# Git pour les hermites
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Créer son repository

						* https://git.vs.ch/projects/new
						* `git clone ssh://git@git.vs.ch:2222/repo.git`
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Ajouter des fichiers

						* `git add src/fichier.txt`

						## Supprimer un fichier

						* `git rm src/fichier.txt`
						
						## Obtenir de l'aid

						* `git help <command>`
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Voir l'état de la working copy

						* `git status`

						## Voir les modifications

						* `git diff`
						* `git diff src/fichier.txt`
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Faire un Commit

						* `git commit -m "message de commit"`

						## Envoyez sur Gitlab

						* `git push`

						## Consulter les commits

						* `git log`
						* `git log src/fichier.txt`
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# Un peu de pratique

						## https://git.vs.ch/formations/git/base/-/blob/main/exercises/exercise-1.md
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# Git is better with friends
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						# Commits
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Contenu d'un commit

						* Atomique
						* Compilable
						* Pas trop grand (ni trop petit)
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Message de commits

						Un bon message de commit décrit ce qui a été fait, mais surtout pourquoi cela à été fait de cette manière.

						L'historique Git doit être vu comme un moyen d'aider à comprendre la raison d'un changement pour faciliter de futurs développements ou corrections de bugs.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Pourquoi ?

						* Pourquoi le changement était nécessaire ?
						* Pourquoi l'avoir fais comme cela ?
						* Ou trouver plus d'information sur ce changement ?

						### Bonnes pratiques

						* Précis et concis
						* Préciser le type de commit (bugfix, refactoring, fonctionnalité, ...)
						* Maximum 50 caractères pour le titre
						* (Utiliser le titre et la description longue)
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Exemples

						* `Add margin`
						* `Add margin to avoid overlapping`
						* `INC123456 - Add margin to avoid overlapping`

						### A éviter

						* `STRY12345 - Administration dashboard`
						* `fix bug`
						* `update packages and fix login`
						* `wip`
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Conventional Commits

						```txt
						<type>[optional scope]: <description>

						[optional body]

						[optional footer(s)]
						```

						Lisible par l'homme et la machine, permet de générer automatiquement des changelog par exemple.
						
						```txt
						fix(network): prevent racing of requests

						Introduce a request id and a reference to latest request.
						Remove timeouts which were used to mitigate the racing issue but are
						obsolete now.

						BREAKING CHANGE: the method setTimeout has been removed from the API

						Reviewed-by: xyz
						Refs: #123
						```
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Commit hash - SHA1

						Chaque commit à un identifiant unique.

						Il s'agit du hash des modifications du commit, ses metadata (auteur, message) et le hash du commit précédant en utilisant la fonction de hashage SHA1.

						Le moindre changement sur une de ses "valeurs" entrainera un changement du hash du commit (rebase, amend, cherry-pick, ...).
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Merge

						L'action d'inclure les changements d'une source vers une destination.
	
						La source et la destination peuvent être:
	
						* des branches
						* des commits
						* des tags
					</textarea>
				</section>

				<section>
					<h3>Merge simple</h3>

					<img src="https://www.bogotobogo.com/cplusplus/images/Git/Fast_Forward_Merge/TypicalMerge.png">
				</section>

				<section>
					<h3>Merge "Fast Forward"</h3>

					<img src="https://www.bogotobogo.com/cplusplus/images/Git/Fast_Forward_Merge/FastForwardMerge.png">
					<img src="https://www.bogotobogo.com/cplusplus/images/Git/Fast_Forward_Merge/FastForwardMergeWith_no_ff.png">
				</section>

				<section data-markdown>
					<textarea data-template>
						## Récupérer depuis Gitlab

						`git fetch` permet de récupèrer les changements depuis Gitlab sans mettre à jour votre Working Copy.

						`git merge --ff  origin/\<branche\>` permet de mettre à jour votre working copy.

						La configuration par défaut de git implique `--ff` et le merge de la branche courante si elle n'est pas passé en paramêtre, un simple `git merge` suffit donc en général.

						Idéalement, il ne faut avoir **aucun changement local** (non commité) au moment de faire un merge.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Et `git pull` dans tout ça ?

						Les actions réalisées dépendent de la configuration (`merge` vs `rebase`), pour garantir même comportement que décrit avant, il faut faire un `git pull --merge --ff`.

						Les IDE implémentent généralement leur "propre version" au lieu d'utiliser la commande git.
						
						Les commandes "Git | Update" et "Git | pull" d'IntellJ font sensiblement la même chose mais en proposant des options différentes.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Conflits

						Lorsque deux personnes modifient le même fichier, il est possible que Git ne sache pas comment réaliser le merge.

						Dans ce cas, il déclare les fichiers en conflits et ne fait pas le commit.

						```

						class HelloWorld {
							public static void main(String[] args) {
						<<<<<<< HEAD
								System.out.println("Bonjour, Monde!"); 
						=======
								System.out.println("Hello everyone!"); 
						>>>>>>> new-hello
							}
						}
						```
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Visual Studio Code
						<img src="https://i.ibb.co/N15hBN9/VS Code.png">
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### IntelliJ		
						<img src="https://i.ibb.co/853YPBw/intellij.png">
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Blame

						`git blame` permet d'annoter un fichier avec des information sur chaque ligne concernant le dernier commit l'ayant modifier.

						On peut ainsi savoir qui est l'auteur du changement et si le message de commit est bon, pourquoi il a été fait.

						Présent de base dans Intellij, [Extension VS Code](https://marketplace.visualstudio.com/items?itemName=W77.git-blame-w77)
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# Un peu de pratique

						## https://git.vs.ch/formations/git/base/-/blob/main/exercises/exercise-2.md
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# `HEAD`, Branches et Tags

						Les trois sont un **pointeur** sur un commit.

						`HEAD` pointe sur le commit actuel de la Working Copy.

						Une branche est un pointeur sur le dernier commit d'une "branche" (...).

						Les tags sont un pointeur fixe.
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# `HEAD`

						`HEAD` point tout simplement sur le commit actuellement représenté dans la working copy.

						`HEAD` va bouger à chaque `commit`, `merge`, `checkout` et tout autre commande changement le contenu de la working copy.

						En général `HEAD` point sur une "feuille" de l'arbre, mais il est possible de le faire pointer sur n'importe quel commit ("Detached HEAD state").
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# Branches

						Chaque commit dans git a une référence vers le SHA1 de son, ou ses, parent(s). L'arbre de commit visible dans Gitlab et votre IDE est généré en utilisant cette information.

						Une "branche" dans le sens strict dans Git est un pointeur vers une des feuilles de cet arbre.

						Le pointeur de branche "avance" automatiquement à chaque fois que vous faites un commit ou que vous vous synchronisez avec le remote.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Créez une branche

						* `git checkout -b <branche>`
						
						La commande `git branch <branche>` va uniquement créer la branche sans se "mettre" dessus.

						## Poussez une branche

						* `git push -u <branche>`
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Supprimez une branche
						
						* `git branch -d <branche>`

						## Rennomez une branche

						* `git branch -m <branche> <branche2>`

						Attention, aucune de ces deux commandes ne renomme ou supprime la branche sur le repository distant ou chez vos collègues.

						Il est possible de réaliser ces opérations en CLI (prochain module) ou de passer directement par gitlab (ne pas oublier le `fetch` après).
					</textarea>
				</section>

			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						## Tags

						Un tag référence un commit précis plutôt que la feuille au sommet d'une branche.

						Un tag permet de marquer un commit important pour pouvoir le retrouver, par exemple une release, la version actuellement en production.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Créez un tag

						* `git tag <tagname>`

						## Supprimer un tag

						* `git tag -d <tagname>`
						* `git push origin :refs/tags/<tagname>`
						* `git fetch --prune --prune-tags` (chez tous les collègues)
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Déplacez un tag

						* `git tag -f <tagname>`
						* `git push origin :refs/tags/<ancien>`
						* `git push origin <tagname>`
						* `git fetch --prune --prune-tags` (chez tous les collègues)

						Ou alors passer directement par gitlab (la dernière étape reste nécessaire chez les collègues)
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Renommez un tag

						* `git tag <nouveau> <ancien>`
						* `git tag -d <ancien>`
						* `git push origin <nouveau> :refs/tags/<ancien>`
						* `git fetch --prune --prune-tags` (chez tous les collègues)

						Ou alors passer directement par gitlab (la dernière étape reste nécessaire chez les collègues)
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# Un peu de pratique

						## https://git.vs.ch/formations/git/base/-/blob/main/exercises/exercise-3.md
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# Retour sur les merges
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### `git merge branch` vs `git merge origin\branch`		
						

					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Gitlab merge request	
						
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# Quelques petits trucs en plus
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## `git show`

						* `git show <ref>:<file>`
						* `git show ma_branche:src/fichier.txt`
						* `git show 2b6dc32f0fb79aae47d3166a8770dc384cacd0d6:src/fichier.txt`
						* `git show 2b6dc32f0fb79aae47d3166a8770dc384cacd0d6`
						* `git show my_branche`
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## .gitignore

						```
						/node_modules
						/target
						/dist

						.vscode/*
						.idea/*

						[...]
						```

						### https://git-scm.com/docs/gitignore
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						## Detached HEAD

						`You are not currently on a branch.`

						### Sans avoir de commit
						```
						git stash
						git checkout <some-branch>
						git stash pop
						```

						### Avec des commits
						```
						git log -1 
						git checkout <some-branch>
						git merge <commit-hash>
						```
					</textarea>
				</section>
			</section>

			<section>
				<section data-markdown>
					<textarea data-template>
						# Un dernier pour la route

						## https://git.vs.ch/formations/git/base/-/blob/main/exercises/exercise-4.md
					</textarea>
				</section>
			</section>
		</div>
	</div>

	<script src="../../../dist/reveal.js"></script>
	<script src="../../../plugin/zoom/zoom.js"></script>
	<script src="../../../plugin/notes/notes.js"></script>
	<script src="../../../plugin/search/search.js"></script>
	<script src="../../../plugin/markdown/markdown.js"></script>
	<script src="../../../plugin/highlight/highlight.js"></script>
	<script src="../../../plugin/mermaid/mermaid.js"></script>
	<script>

		// Also available as an ES module, see:
		// https://revealjs.com/initialization/
		Reveal.initialize({
			controls: true,
			progress: true,
			center: true,
			hash: true,
			width: 1600,
			height: 1080,

			showNotes: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMermaid]
		});

	</script>

</body>

</html>